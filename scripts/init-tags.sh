#!/usr/bin/env bash
set -euo pipefail

# Initialize tags.txt files for images under containers/openami by inspecting
# version/distro build contexts and, when available, deriving tag versions from
# prebuildfs/opt/bitnami/.bitnami_components.json.
#
# Tag format (best-effort):
#   <baseVersion>-<distro>-r<release>
#   e.g., 1.29.1-debian-12-r0
#
# Each tags.txt line will include:
#   <tag> <relative_context>
#   e.g., 1.29.1-debian-12-r0 1.29/debian-12
#
# Notes:
# - This is a best-effort initializer to bootstrap strict builds without relying on images.txt.
# - If a components file is not present or doesn't match expected patterns, we will fall back to:
#     <version_dir>-<distro>
#   (without -rN), which you can adjust manually per image as needed.

OPENAMI_DIR="${OPENAMI_DIR:-containers/openami}"
created=0
updated=0
skipped=0

if [[ ! -d "${OPENAMI_DIR}" ]]; then
  echo "ERROR: Directory not found: ${OPENAMI_DIR}" >&2
  exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
  echo "ERROR: jq is required to parse component metadata" >&2
  exit 1
fi

infer_tag() {
  local image="$1"      # image name (dir basename)
  local context="$2"    # full path to version/distro dir that contains Dockerfile
  local version_dir distro tag

  distro="$(basename "$context")"
  version_dir="$(basename "$(dirname "$context")")"

  # Default tag fallback
  tag="${version_dir}-${distro}"

  # Attempt to read bitnami components file
  local comp="${context}/prebuildfs/opt/bitnami/.bitnami_components.json"
  if [[ -f "$comp" ]]; then
    # Try to pick version from a key that matches the image name; otherwise first entry
    local comp_version
    comp_version="$(jq -r --arg k "$image" '.[$k].version // (to_entries[0].value.version // empty)' "$comp" || true)"
    # comp_version is typically like "1.29.1-0"
    if [[ -n "$comp_version" ]]; then
      if [[ "$comp_version" =~ ^([0-9]+\.[0-9]+(\.[0-9]+)?)\-([0-9]+)$ ]]; then
        local base="${BASH_REMATCH[1]}"
        local rel="${BASH_REMATCH[3]}"
        tag="${base}-${distro}-r${rel}"
      fi
    fi
  fi

  printf "%s" "$tag"
}

# Iterate each image directory under OPENAMI_DIR
while IFS= read -r -d '' imgdir; do
  image="$(basename "$imgdir")"
  tfile="${imgdir}/tags.txt"

  # Find contexts that contain a Dockerfile (e.g., 1.29/debian-12)
  mapfile -t contexts < <(find "$imgdir" -type f -name Dockerfile -printf '%h\n' | sort -u)

  if [[ ${#contexts[@]} -eq 0 ]]; then
    echo "WARN: No Dockerfile contexts found for image '${image}', skipping."
    skipped=$((skipped+1))
    continue
  fi

  # Build new tags content
  tmp="$(mktemp)"
  {
    echo "# Auto-generated by scripts/init-tags.sh"
    echo "# Format: <tag> <relative_context>"
  } > "$tmp"

  for ctx in "${contexts[@]}"; do
    rel_ctx="${ctx#${imgdir}/}" # relative path under image dir, e.g., 1.29/debian-12
    tag="$(infer_tag "$image" "$ctx")"
    printf "%s %s\n" "$tag" "$rel_ctx" >> "$tmp"
  done

  if [[ -f "$tfile" ]]; then
    if ! diff -q "$tfile" "$tmp" >/dev/null 2>&1; then
      mv "$tmp" "$tfile"
      echo "Updated tags.txt for image '${image}'"
      updated=$((updated+1))
    else
      rm -f "$tmp"
      echo "No change for image '${image}' (tags.txt already matches)"
      skipped=$((skipped+1))
    fi
  else
    mv "$tmp" "$tfile"
    echo "Created tags.txt for image '${image}'"
    created=$((created+1))
  fi
done < <(find "${OPENAMI_DIR}" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)

echo "Summary: created=${created}, updated=${updated}, skipped=${skipped}"
